use bamboo::{
  chat::Chat,
  util::FPos,
  player::Player,
}

// Stores all the game info
struct Bedwars {
  teams: map,
  players: map,
  in_game: bool,
  countdown: int,
}
// Stores info for a player
struct BedwarsPlayer {
  player: Player,
  // A number of ticks
  time_to_respawn: int,

  team_name: str,
  spawn: Pos,
  spawn_yaw: float,
}
// Stores info for a team
struct Team {
  players: arr,
  spawn: Pos,
  spawn_yaw: float,
}

fn init() {
  bamboo::info("initializing bedwars")

  teams = map {
    "red":    Team { players: [], spawn: FPos::new(0.0,   61.0, -40.0), spawn_yaw: 0.0 },
    "green":  Team { players: [], spawn: FPos::new(40.0,  61.0, 0.0  ), spawn_yaw: 90.0 },
    "aqua":   Team { players: [], spawn: FPos::new(0.0,   61.0, 40.0 ), spawn_yaw: 180.0 },
    "yellow": Team { players: [], spawn: FPos::new(-40.0, 61.0, 0.0  ), spawn_yaw: 270.0 },
  }
  bb = bamboo::instance()
  bb.store(Bedwars {
    teams: teams,
    players: map {},
    in_game: false,
    countdown: 0,
  })
}

fn start_game(bb) {

}

fn on_click_window(player, slot, mode) {
  true
}

fn on_block_place(player, pos, kind) {
}

fn on_player_join(player) {
  bb = bamboo::instance()
  bedwars = bb.lock()

  team = bedwars.find_smallest_team()
  bamboo::info("Adding " + player.username() + " to " + team)
  bedwars.add_player_to_team(player, team)
  bedwars.teleport_to_spawn(player)

  bb.unlock(bedwars)
}

fn on_tick() {
  bb = bamboo::instance()
  bedwars = bb.lock()

  bedwars.tick()

  bb.unlock(bedwars)
}

impl Bedwars {
  fn teleport_to_spawn(self, player) {
    team = self.teams[self.players[player.username()].team_name]
    player.teleport(team.spawn, team.spawn_yaw, 0.0)
  }

  fn find_smallest_team(self) {
    smallest_size = 100
    smallest_team = ""
    keys = self.teams.keys()
    for i = 0, i < self.teams.len(), i++ {
      color = keys[i]
      if self.teams[color].players.len() < smallest_size {
        smallest_team = color
        smallest_size = self.teams[color].players.len()
      }
    }
    smallest_team
  }

  fn add_player_to_team(self, player, team) {
    line = Chat::new("Team: ")
    line.add(team).color(team)
    player.show_scoreboard()
    player.set_scoreboard_line(8, line)
    player.set_scoreboard_line(7, Chat::new(""))
    self.set_scoreboard_status(player)
    keys = self.players.keys()
    for i = 0, i < self.players.len(), i++ {
      self.set_scoreboard_player_count(self.players[keys[i]].player)
    }

    name = Chat::empty()
    name.add(player.username()).color(team)
    player.set_display_name(name)

    spawn = self.teams[team].spawn
    spawn_yaw = self.teams[team].spawn_yaw
    p = BedwarsPlayer::new(player, team, spawn, spawn_yaw)
    self.teams[team].players.push(p)
    self.players.insert(player.username(), p)

    if self.players.len() >= 4 {
      self.start_countdown()
    }
  }

  fn set_scoreboard_status(self, player) {
    if self.in_game {
      // parsing is bugged, i can't have an empty block here
      1 + 2
    } else {
      player.set_scoreboard_line(6, Chat::new("Waiting for"))
      player.set_scoreboard_line(5, Chat::new("players..."))

      self.set_scoreboard_player_count(player)
      player.set_scoreboard_line(3, Chat::new(""))
      if self.countdown > 0 {
        self.set_scoreboard_countdown(player)
      }
    }
  }
  fn set_scoreboard_player_count(self, player) {
    line = Chat::empty()
    line.add((self.players.len() + 1).to_s() + "/12").color("yellow")
    player.set_scoreboard_line(4, line)
  }
  fn set_scoreboard_countdown(self, player) {
    player.set_scoreboard_line(2, Chat::new("Starting in " + self.countdown / 20))
  }

  fn tick(self) {
    if self.in_game {
      keys = self.players.keys()
      for i = 0, i < self.players.len(), i++ {
        username = keys[i]
        self.players[username].tick()
      }
    } else if self.countdown == 1 {
      self.countdown = 0
      keys = self.players.keys()
      for i = 0, i < self.players.len(), i++ {
        username = keys[i]
        self.players[username].start()
      }
    } else if self.countdown > 0 {
      if self.countdown <= 100 {
        if self.time_to_respawn % 20 == 0 {
          msg = Chat::empty()
          msg.add((self.time_to_respawn / 20).to_s()).color("red")

          keys = self.players.keys()
          for i = 0, i < self.players.len(), i++ {
            username = keys[i]
            self.players[username].player.set_title(msg)
            self.players[username].player.show_title(0, 20, 0)
          }
        }
      }
      if self.countdown % 20 == 0 {
        keys = self.players.keys()
        for i = 0, i < self.players.len(), i++ {
          username = keys[i]
          self.set_scoreboard_countdown(self.players[username].player)
        }
      }
      self.countdown--
    }
  }

  fn start_countdown(self) {

  }
}

impl BedwarsPlayer {
  fn new(player, team_name, spawn, spawn_yaw) {
    BedwarsPlayer {
      player: player,
      time_to_respawn: 5 * 20,
      team_name: team_name,
      spawn: spawn,
      spawn_yaw: spawn_yaw,
    }
  }

  fn tick(self) {
    if self.time_to_respawn == 1 {
      self.time_to_respawn = 0
      self.teleport_to_spawn()
    } else if self.time_to_respawn > 0 {
      if self.time_to_respawn % 20 == 0 {
        msg = Chat::empty()
        msg.add((self.time_to_respawn / 20).to_s()).color("red")
        self.player.set_title(msg)
        self.player.show_title(0, 20, 0)
      }
      self.time_to_respawn--
    }
  }

  fn teleport_to_spawn(self) {
    self.player.teleport(self.spawn, self.spawn_yaw, 0.0)
  }

  fn start(self) {
    self.teleport_to_spawn()
  }

  fn alive(self) {
    self.time_to_respawn == 0
  }
}
