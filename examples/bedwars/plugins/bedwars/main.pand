use bamboo::{
  chat::Chat,
  util::FPos,
  item,
  player::Player,
  world::World,
}

// Stores all the game info
struct Bedwars {
  teams: map,
  players: map,
  in_game: bool,
  countdown: int,
}
// Stores info for a player
struct BedwarsPlayer {
  player: Player,
  // A number of ticks
  time_to_respawn: int,

  team_name: str,
  spawn: Pos,
  spawn_yaw: float,
}
// Stores info for a team
struct Team {
  players: arr,
  spawn: FPos,
  spawn_yaw: float,
  resource_spawn: FPos,
  world: World,
  iron_spawn_time: int,
  gold_spawn_time: int,
}

fn init() {
  bamboo::info("initializing bedwars")

  bb = bamboo::instance()
  world = bb.default_world()
  teams = map {
    "red":    Team::new(world, FPos::new(0.0,   61.0, -40.0), 0.0,   FPos::new(0.5,   62.0, -44.5)),
    "green":  Team::new(world, FPos::new(40.0,  61.0, 0.0  ), 90.0,  FPos::new(44.5,  62.0, 0.5  )),
    "aqua":   Team::new(world, FPos::new(0.0,   61.0, 40.0 ), 180.0, FPos::new(0.5,   62.0, 44.5 )),
    "yellow": Team::new(world, FPos::new(-40.0, 61.0, 0.0  ), 270.0, FPos::new(-44.5, 62.0, 0.5  )),
  }
  bb.store(Bedwars {
    teams: teams,
    players: map {},
    in_game: true,
    countdown: 0,
  })
}

fn start_game(bb) {

}

fn on_click_window(player, slot, mode) {
  true
}

fn on_block_place(player, pos, kind) {
}

fn on_player_join(player) {
  bb = bamboo::instance()
  bedwars = bb.lock()

  team = bedwars.find_smallest_team()
  bamboo::info("Adding " + player.username() + " to " + team)
  p = bedwars.add_player_to_team(player, team)
  p.teleport_to_lobby()

  bb.unlock(bedwars)
}

fn on_tick() {
  bb = bamboo::instance()
  bedwars = bb.lock()

  bedwars.tick()

  bb.unlock(bedwars)
}

impl Bedwars {
  fn teleport_to_spawn(self, player) {
    team = self.teams[self.players[player.username()].team_name]
    player.teleport(team.spawn, team.spawn_yaw, 0.0)
  }

  fn find_smallest_team(self) {
    smallest_size = 100
    smallest_team = ""
    keys = self.teams.keys()
    for i = 0, i < self.teams.len(), i++ {
      color = keys[i]
      if self.teams[color].players.len() < smallest_size {
        smallest_team = color
        smallest_size = self.teams[color].players.len()
      }
    }
    smallest_team
  }

  fn add_player_to_team(self, player, team) {
    line = Chat::new("Team: ")
    line.add(team).color(team)
    player.show_scoreboard()
    player.set_scoreboard_line(8, line)
    player.set_scoreboard_line(7, Chat::new(""))
    self.set_scoreboard_status(player)
    keys = self.players.keys()
    for i = 0, i < self.players.len(), i++ {
      self.set_scoreboard_player_count(self.players[keys[i]].player)
    }

    name = Chat::empty()
    name.add(player.username()).color(team)
    player.set_display_name(name)

    spawn = self.teams[team].spawn
    spawn_yaw = self.teams[team].spawn_yaw
    p = BedwarsPlayer::new(player, team, spawn, spawn_yaw)
    self.teams[team].players.push(p)
    self.players.insert(player.username(), p)

    if self.players.len() >= 4 {
      self.start_countdown()
    }
    p
  }

  fn set_scoreboard_status(self, player) {
    if self.in_game {
      // parsing is bugged, i can't have an empty block here
      1 + 2
    } else {
      self.set_scoreboard_player_count(player)
      player.set_scoreboard_line(4, Chat::new(""))
      if self.countdown > 0 {
        self.set_scoreboard_countdown(player)
      }
    }
  }
  fn set_scoreboard_player_count(self, player) {
    line = Chat::new("players: ")
    line.add((self.players.len() + 1).to_s() + "/12").color("yellow")
    player.set_scoreboard_line(6, Chat::new("Waiting for"))
    player.set_scoreboard_line(5, line)
  }
  fn set_scoreboard_countdown(self, player) {
    line = Chat::new("Starting in ")
    line.add((self.countdown / 20).to_s()).color("yellow")
    player.set_scoreboard_line(3, line)
  }

  fn tick(self) {
    keys = self.players.keys()
    msg = 0 // placeholder
    if self.in_game {
      for i = 0, i < self.players.len(), i++ {
        username = keys[i]
        self.players[username].tick()
      }
      keys = self.teams.keys()
      for i = 0, i < self.teams.len(), i++ {
        self.teams[keys[i]].tick()
      }
    } else if self.countdown == 1 {
      self.countdown = 0
      for i = 0, i < self.players.len(), i++ {
        username = keys[i]
        self.players[username].start()
      }
    } else if self.countdown > 0 {
      if self.countdown <= 100 {
        if self.countdown % 20 == 0 {
          msg = Chat::empty()
          msg.add((self.countdown / 20).to_s()).color("red")

          for i = 0, i < self.players.len(), i++ {
            username = keys[i]
            self.players[username].player.set_title(msg)
            self.players[username].player.show_title(0, 20, 0)
          }
        }
      }
      if self.countdown % 20 == 0 {
        for i = 0, i < self.players.len(), i++ {
          username = keys[i]
          self.set_scoreboard_countdown(self.players[username].player)
        }
      }
      self.countdown--
    }
  }

  fn start_countdown(self) {
    self.countdown = 15 * 20
  }
}

impl BedwarsPlayer {
  fn new(player, team_name, spawn, spawn_yaw) {
    BedwarsPlayer {
      player: player,
      time_to_respawn: 5 * 20,
      team_name: team_name,
      spawn: spawn,
      spawn_yaw: spawn_yaw,
    }
  }

  fn tick(self) {
    if self.time_to_respawn == 1 {
      self.time_to_respawn = 0
      self.teleport_to_spawn()
    } else if self.time_to_respawn > 0 {
      if self.time_to_respawn % 20 == 0 {
        msg = Chat::empty()
        msg.add((self.time_to_respawn / 20).to_s()).color("red")
        self.player.set_title(msg)
        self.player.show_title(0, 20, 0)
      }
      self.time_to_respawn--
    }
  }

  fn teleport_to_spawn(self) {
    self.player.teleport(self.spawn, self.spawn_yaw, 0.0)
  }
  fn teleport_to_lobby(self) {
    self.player.teleport(FPos::new(0.0, 70.0, 0.0), 0.0, 0.0)
  }

  fn start(self) {
    self.teleport_to_spawn()
  }

  fn alive(self) {
    self.time_to_respawn == 0
  }
}

impl Team {
  fn new(world, spawn, yaw, resource_spawn) {
    Team {
      players: [],
      spawn: spawn,
      spawn_yaw: yaw,
      resource_spawn: resource_spawn,
      world: world,
      iron_spawn_time: 0,
      gold_spawn_time: 0,
    }
  }
  fn tick(self) {
    if self.iron_spawn_time == 0 {
      self.iron_spawn_time = 5 * 20
      self.world.summon_item(self.resource_spawn, item::Stack::new("iron_ingot"))
    }
    self.iron_spawn_time--
    if self.gold_spawn_time == 0 {
      self.gold_spawn_time = 20 * 20
      self.world.summon_item(self.resource_spawn, item::Stack::new("gold_ingot"))
    }
    self.gold_spawn_time--
  }
}
